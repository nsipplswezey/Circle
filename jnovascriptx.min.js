sprintfWrapper = {
  init: function() {
    if (typeof arguments == "undefined") {
      return null
    }
    if (arguments.length < 1) {
      return null
    }
    if (typeof arguments[0] != "string") {
      return null
    }
    if (typeof RegExp == "undefined") {
      return null
    }
    var j = arguments[0];
    var c = new RegExp(/(%([%]|(\-)?(\+|\x20)?(0)?(\d+)?(\.(\d)?)?([bcdfosxX])))/g);
    var g = new Array();
    var l = new Array();
    var a = 0;
    var h = 0;
    var m = 0;
    var d = 0;
    var k = "";
    var f = null;
    while (f = c.exec(j)) {
      if (f[9]) {
        a += 1
      }
      h = d;
      m = c.lastIndex - f[0].length;
      l[l.length] = j.substring(h, m);
      d = c.lastIndex;
      g[g.length] = {
        match: f[0],
        left: f[3] ? true : false,
        sign: f[4] || "",
        pad: f[5] || " ",
        min: f[6] || 0,
        precision: f[8],
        code: f[9] || "%",
        negative: parseInt(arguments[a]) < 0 ? true : false,
        argument: String(arguments[a])
      }
    }
    l[l.length] = j.substring(d);
    if (g.length == 0) {
      return j
    }
    if ((arguments.length - 1) < a) {
      return null
    }
    var b = null;
    var f = null;
    var e = null;
    for (e = 0; e < g.length; e++) {
      if (g[e].code == "%") {
        substitution = "%"
      } else {
        if (g[e].code == "b") {
          g[e].argument = String(Math.abs(parseInt(g[e].argument)).toString(2));
          substitution = sprintfWrapper.convert(g[e], true)
        } else {
          if (g[e].code == "c") {
            g[e].argument = String(String.fromCharCode(parseInt(Math.abs(parseInt(g[e].argument)))));
            substitution = sprintfWrapper.convert(g[e], true)
          } else {
            if (g[e].code == "d") {
              g[e].argument = String(Math.abs(parseInt(g[e].argument)));
              substitution = sprintfWrapper.convert(g[e])
            } else {
              if (g[e].code == "f") {
                g[e].argument = String(Math.abs(parseFloat(g[e].argument)).toFixed(g[e].precision ? g[e].precision : 6));
                substitution = sprintfWrapper.convert(g[e])
              } else {
                if (g[e].code == "o") {
                  g[e].argument = String(Math.abs(parseInt(g[e].argument)).toString(8));
                  substitution = sprintfWrapper.convert(g[e])
                } else {
                  if (g[e].code == "s") {
                    g[e].argument = g[e].argument.substring(0, g[e].precision ? g[e].precision : g[e].argument.length);
                    substitution = sprintfWrapper.convert(g[e], true)
                  } else {
                    if (g[e].code == "x") {
                      g[e].argument = String(Math.abs(parseInt(g[e].argument)).toString(16));
                      substitution = sprintfWrapper.convert(g[e])
                    } else {
                      if (g[e].code == "X") {
                        g[e].argument = String(Math.abs(parseInt(g[e].argument)).toString(16));
                        substitution = sprintfWrapper.convert(g[e]).toUpperCase()
                      } else {
                        substitution = g[e].match
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      k += l[e];
      k += substitution
    }
    k += l[e];
    return k
  },
  convert: function(b, d) {
    if (d) {
      b.sign = ""
    } else {
      b.sign = b.negative ? "-" : b.sign
    }
    var a = b.min - b.argument.length + 1 - b.sign.length;
    var c = new Array(a < 0 ? 0 : a).join(b.pad);
    if (!b.left) {
      if (b.pad == "0" || d) {
        return b.sign + c + b.argument
      } else {
        return c + b.sign + b.argument
      }
    } else {
      if (b.pad == "0" || d) {
        return b.sign + b.argument + c.replace(/0/g, " ")
      } else {
        return b.sign + b.argument + c
      }
    }
  }
};
sprintf = sprintfWrapper.init;

function comp_proto(a, b) {
  this.name = a;
  this.kind = b;
  this.exp = "0.0";
  this._exp = "0.0"
}
comp_proto.prototype.value = function() {
  return eval(this.exp)
};
comp_proto.prototype.getName = function(a) {
  return (a) ? a.name : ""
};
comp_proto.prototype.isKind = function(a) {
  return this.kind == a
};
comp_proto.prototype.isIterable = function() {
  return this.isStock() || this.isSequence()
};
comp_proto.prototype.isCommand = function() {
  return this.isKind("Command")
};
comp_proto.prototype.isFlow = function() {
  return this.isKind("Flow")
};
comp_proto.prototype.isTerm = function() {
  return this.isKind("Term")
};
comp_proto.prototype.isSequence = function() {
  return this.isKind("Sequence")
};
comp_proto.prototype.isStock = function() {
  return this.isKind("Stock")
};

function Iterable(a, b) {
  comp_proto.call(this, a, b);
  this.last = "0.0";
  this.values = new Object();
  this.init = null
}
Iterable.prototype = Object.create(comp_proto.prototype);
Iterable.prototype.constructor = Iterable;
Iterable.prototype.value = function(a) {
  return interpolate(a, this.values)
};
Iterable.prototype.reset = function(a) {
  this.values = new Object();
  this.store(a.lo, this.init.call(this.cap.scope))
};
Iterable.prototype.store = function(a, b) {
  this.last = this.values[a] = b
};
Iterable.prototype.__defineGetter__("initial", function() {
  return this._exp
});
Iterable.prototype.__defineSetter__("initial", function(e) {
  this._exp = e;
  eval(sprintf("function init(){return %s;}", e));
  this.init = init
});
Iterable.prototype.show = function() {
  return this.values.toSource()
};
Iterable.prototype.clear = function(a) {
  delete this.values[a]
};
Iterable.prototype.current = function() {
  return this.last
};

function Stock(a) {
  Iterable.call(this, a, "Stock");
  this.deriv = function(b) {
    return 0
  };
  this.inFlow = null;
  this.outFlow = null;
  this.k0 = this.k1 = this.k2 = this.k3 = null
}
Stock.prototype = Object.create(Iterable.prototype);
Stock.prototype.constructor = Stock;
Stock.prototype.setInFlow = function(a) {
  this.inFlow = a;
  a.outp = this;
  this.fixDeriv()
};
Stock.prototype.setOutFlow = function(a) {
  this.outFlow = a;
  a.inp = this;
  this.fixDeriv()
};
Stock.prototype.update = function(a, b, c) {
  this.store(a + b, this.values[a] + c)
};
Stock.prototype.getDeriv = function() {
  return this.deriv
};
Stock.prototype.current = function() {
  return this.last
};
Stock.prototype.fixDeriv = function() {
  if (this.inFlow == null && this.outFlow == null) {
    return
  }
  if (this.outFlow == null) {
    eval(sprintf("function dhi(t){return %s;}", this.inFlow.exp));
    this.deriv = dhi
  } else {
    if (this.inFlow == null) {
      eval(sprintf("function dlo(t){return -(%s);}", this.outFlow.exp));
      this.deriv = dlo
    } else {
      eval(sprintf("function deriv(t){return %s - %s}", this.inFlow.exp, this.outFlow.exp));
      this.deriv = deriv
    }
  }
};
Stock.prototype.toString = function() {
  return sprintf("[Stock %s %s %s]", this.name, this.getName(this.inFlow), this.getName(this.outFlow))
};

function Sequence(a) {
  Iterable.call(this, a, "Sequence");
  next = "0"
}
Sequence.prototype = Object.create(Iterable.prototype);
Sequence.prototype.toString = function() {
  return sprintf("[Sequence %s]", this.name);
  delete this.deriv
};
Sequence.prototype.__defineSetter__("next", function(exp) {
  this._next = exp;
  eval(sprintf("function doNext(t){return %s;}", exp));
  this.doNext = doNext
});
Sequence.prototype.__defineGetter__("next", function() {
  return this._next
});
Sequence.prototype.update = function(a, b, c) {
  this.store(a + b, c)
};

function Flow(b, c, a) {
  comp_proto.call(this, b, "Flow");
  this.inp = c;
  this.outp = a;
  this._exp = "0.0"
}
Flow.prototype = Object.create(comp_proto.prototype);
Flow.prototype.constructor = Flow;
Flow.prototype.__defineGetter__("exp", function() {
  return this._exp
});
Flow.prototype.__defineSetter__("exp", function(a) {
  this._exp = a;
  if (this.inp) {
    this.inp.fixDeriv()
  }
  if (this.outp) {
    this.outp.fixDeriv()
  }
});
Flow.prototype.reset = function(a) {};
Flow.prototype.toString = function() {
  return sprintf("[Flow %s %s %s]", this.name, this.getName(this.inp), this.getName(this.outp))
};

function Term(a) {
  comp_proto.call(this, a, "Term");
  this.cache = new Cachemaker(this.exp);
  this.value = function(b) {
    return this.cache.f(b, this.cap)
  }
}
Term.prototype = Object.create(comp_proto.prototype);
Term.prototype.__defineGetter__("exp", function() {
  return this._exp
});
Term.prototype.__defineSetter__("exp", function(a) {
  this._exp = a;
  this.cache = new Cachemaker(a);
  this.value = function(b) {
    return this.cache.f(b, this.cap)
  }
});
Term.prototype.reset = function(a) {
  this.cache.reset()
};
Term.prototype.toString = function() {
  return sprintf("[Term %s]", this.name)
};
Term.prototype.constructor = Term;

function Command(name, preOrPost) {
  comp_proto.call(this, name, "Command");
  eval(sprintf("function block(t){%s}", this.exp));
  this.value = block;
  this.preOrPost = preOrPost
}
Command.prototype = Object.create(comp_proto.prototype);
Command.prototype.__defineGetter__("exp", function() {
  return this._exp
});
Command.prototype.__defineSetter__("exp", function(e) {
  this._exp = e;
  eval(sprintf("function block(t){%s}", e));
  this.value = block
});
Command.prototype.reset = function(a) {};
Command.prototype.toString = function() {
  return sprintf("[Command %s]", this.name)
};
Command.prototype.execute = function(a, b) {
  this.value.call(b, a.current)
};
Command.prototype.constructor = Command;

function Capsule(c, e) {
  comp_proto.call(this, c, "Capsule");
  this.components = new Object();
  for (var d = 0; d < e.length; d++) {
    this.components[e[d].name] = e[d]
  }
  this.clock = null;
  this.scope = null;
  this.iterables = new Array();
  this.precoms = new Array();
  this.postcoms = new Array();
  for (var a in this.components) {
    var b = this.components[a];
    this[b.name] = b;
    b.cap = this;
    if (b.isIterable()) {
      this.iterables.push(b)
    }
    if (b.isCommand()) {
      if (b.preOrPost == "pre") {
        this.precoms.push(b)
      }
      if (b.preOrPost == "post") {
        this.postcoms.push(b)
      }
    }
  }
}
Capsule.prototype = Object.create(comp_proto.prototype);
Capsule.prototype.constructor = Capsule;
Capsule.prototype.reset = function(b) {
  this.clock = b;
  this.scopemaker = scopemaker(this.components, this);
  this.scope = new this.scopemaker(b.lo);
  for (var a in this.components) {
    this.components[a].reset(b)
  }
};
Capsule.prototype.iterate = function(b, d) {
  if (d == "k0") {
    this.scope0 = this.scope
  } else {
    this.scope = new this.scopemaker(b)
  }
  for (var c in this.iterables) {
    integrator(this.clock.method, this.iterables[c], this.clock.current, this.clock.dt, this.scope, d)
  }
  if (this.clock.method == "Euler" || (this.clock.method == "RK4" && d == "k3")) {

    //A robust type checker:
    //Object.prototype.toString.call(d) === "[object Object]"
    //See: https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/
    //this.precoms is at one point an integer
    //and we don't want to do anything with an integer

    if( Object.prototype.toString.call(this.precoms) === "[object Object]"){
      for (var a in this.precoms) {
        this.precoms[a].execute(this.clock, this.scope0)
      }
    }
  }
};
Capsule.prototype.toString = function() {
  return sprintf("[Capsule %s %s]", this.name, Object.keys(this.components))
};
Capsule.prototype.postProcess = function(b) {
  this.scope = new this.scopemaker(b);

  //A robust type checker:
  //Object.prototype.toString.call(d) === "[object Object]"
  //See: https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/
  //this.precoms is at one point an integer
  //and we don't want to do anything with an integer

  if( Object.prototype.toString.call(this.postcoms) === "[object Object]"){
    for (var a in this.postcoms) {
      this.postcoms[a].execute(this.clock, this.scope)
    }
  }
};

function Agent(a, c, b) {
  comp_proto.call(this, "A_" + a.name, "Agent");
  this.cap = a;
  this.agentvector = b;
  this.id = c;
  this.x = 0;
  this.y = 0;
  this.theta = 0
}
Agent.prototype = Object.create(comp_proto.prototype);
Agent.prototype.constructor = Agent;
Agent.prototype.reset = function(a) {
  this.cap.reset(a);
  this.x = (this.cap.init_x) ? this.cap.init_x.value(a.lo) : 0;
  this.y = (this.cap.init_y) ? this.cap.init_y.value(a.lo) : 0;
  this.theta = (this.cap.init_theta) ? this.cap.init_theta.value(a.lo) : 0
};
Agent.prototype.toString = function() {
  return sprintf("[Agent %s]", this.name, this.cap.name, this.id)
};
Agent.prototype.MOVETO = function(a, b) {
  this.x = wrap(a, this.agentvector.cols);
  this.y = wrap(b, this.agentvector.rows);
  this.wrapped = (this.x != a) || (this.y != b)
};
Agent.prototype.MOVEPLUS = function(a, d) {
  var b = this.x + a;
  var c = this.y + d;
  this.x = wrap(b, this.agentvector.cols);
  this.y = wrap(c, this.agentvector.rows);
  this.wrapped = (this.x != b) || (this.y != c)
};
Agent.prototype.MOVEPLUSR = function(c) {
  var a = this.x + c * Math.cos(this.theta);
  var b = this.y + c * Math.sin(this.theta);
  this.x = wrap(a, this.agentvector.cols);
  this.y = wrap(b, this.agentvector.rows);
  this.wrapped = (this.x != a) || (this.y != b)
};
Agent.prototype.NEWTHETA = function(a) {
  this.theta = wrap(a, 2 * Math.PI)
};

function AgentVector(a, d, f, g, h) {
  comp_proto.call(this, a, "AgentVector");
  this.capgen = d;
  this.count = f;
  this.rows = g;
  this.cols = h;
  this.vector = new Array();
  for (var c = 0; c < this.count; c++) {
    var b = d(c);
    var e = new Agent(b, c, this);
    b.agent = e;
    b.agentvector = this;
    this.vector.push(e)
  }
}
AgentVector.prototype = Object.create(comp_proto.prototype);
AgentVector.prototype.constructor = AgentVector;
AgentVector.prototype.toString = function() {
  return sprintf("[AgentVector %s %s]", this.name, this.capgen.name)
};
AgentVector.prototype.iterate = function(b, c) {
  if (this.clock.method == "Euler" || (this.clock.method == "RK4" && c == "k3")) {
    for (var a = 0; a < this.vector.length; a++) {
      this.vector[a].cap.iterate(b, c)
    }
  }
  AgentVector.prototype.postProcess = function(e) {
    this.scope = new this.scopemaker(e);
    for (var d = 0; d < this.vector.length; d++) {
      this.vector[d].cap.postProcess(e)
    }
  }
};
AgentVector.prototype.reset = function(b) {
  this.clock = b;
  this.scopemaker = scopemaker([], this);
  this.scope = new this.scopemaker(b.lo);
  for (var a = 0; a < this.vector.length; a++) {
    this.vector[a].reset(b)
  }
};

function Clock(b, a, c, d) {
  this.lo = b;
  this.hi = a;
  this.dt = (c) ? c : 1;
  this.current = b;
  this.method = (d) ? d : "Euler"
}
Clock.prototype.reset = function(a) {
  this.current = this.lo;
  if (a) {
    this.capsule = a
  }
  this.capsule.reset(this)
};
Clock.prototype.step = function() {
  switch (this.method) {
    case "Euler":
      this.capsule.iterate(this.current, this.epochs[0]);
      break;
    case "RK4":
      var b = [this.current, this.current + this.dt / 2, this.current + this.dt / 2, this.current + this.dt];
      for (var a in this.epochs) {
        this.capsule.iterate(b[a], this.epochs[a])
      }
      break
  }
  this.current += this.dt;
  this.capsule.postProcess(this.current)
};
Clock.prototype.epochs = ["k0", "k1", "k2", "k3"];
Clock.prototype.run = function() {
  var b = (arguments.length == 0) ? this.hi : arguments[0];
  for (var a = this.current; a <= b - this.dt; a += this.dt) {
    this.step()
  }
};
Clock.prototype.toString = function() {
  return sprintf("[Clock %f %f %f %s]", this.lo, this.hi, this.dt, this.method)
};

function scopemaker(d, b) {
  var a = function(f) {
    this.toString = function() {
      return sprintf("[Scope %s %f]", b.name, f)
    };
    this.TIME = f;
    var g = this;

    //A robust type checker:
    //Object.prototype.toString.call(d) === "[object Object]"
    //See: https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/
    //d is at one point an integer
    //and we don't want to do anything with an integer

    if(d && Object.prototype.toString.call(d) === "[object Object]") {
      for (var e in d) {
        if (d[e].isCommand() || d[e].isFlow()) {
          continue
        }
        g.__defineGetter__(d[e].name, (function() {
          var i = f;
          var h = d[e];
          return function() {
            return h.value(i)
          }
        })())
      }
    }


  };
  a.prototype = Object.create(b.__proto__.constructor.prototype);
  a.prototype.constructor = a;
  for (var c in b) {
    if (b.hasOwnProperty(c)) {
      a.prototype[c] = b[c]
    }
  }
  return a
}

function integrator(a, f, h, c, k, b) {
  switch (f.kind) {
    case "Sequence":
      if (a == "Euler" || (a == "RK4" && b == "k3")) {
        var j = f.doNext.call(k, h);
        f.update(h, c, j * c)
      }
      break;
    case "Stock":
      switch (a) {
        case "Euler":
          var j = f.getDeriv().call(k, h);
          f.update(h, c, j * c);
          break;
        case "RK4":
          switch (b) {
            case "k0":
              var i = f.getDeriv().call(k, h);
              f.update(h, c / 2, c / 2 * i);
              f.k1 = i;
              break;
            case "k1":
              var g = f.getDeriv().call(k, h + c / 2);
              f.update(h, c / 2, c / 2 * g);
              f.k2 = g;
              break;
            case "k2":
              var e = f.getDeriv().call(k, h + c / 2);
              f.update(h, c, c * e);
              f.k3 = e;
              break;
            case "k3":
              var d = f.getDeriv().call(k, h + c);
              f.clear(h + c / 2);
              f.update(h, c, (c / 6) * (f.k1 + 2 * f.k2 + 2 * f.k3 + d));
              break
          }
      }
  }
}

function Cachemaker(exp) {
  eval(sprintf("function f0(t){return %s;}", exp));
  this.cache = null;
  this.t0 = null;
  this.reset = function() {
    this.cache = null;
    this.t0 = null
  };
  var that = this;
  this.f = function(t, cap) {
    if (t != that.t0) {
      that.t0 = t;
      that.cache = f0.call(cap.scope, t)
    }
    return that.cache
  }
}

function wrap(b, a) {
  if (b >= 0 && b < a) {
    return b
  }
  return ((b % a) + a) % a
}

function interpolate(b, f) {
  if (f[b] != undefined) {
    return f[b]
  }
  var d = Object.keys(f);
  if (b < d[0]) {
    return f[0]
  }
  if (b > d[d.length - 1]) {
    return f[d[d.length - 1]]
  }
  var a = binaryIndexOf(d, b);
  var c = d[a];
  var e = d[a - 1];
  return f[e] + ((f[c] - f[e]) / (c - e)) * (b - e)
}

function binaryIndexOf(a, e) {
  var d = 0;
  var f = a.length - 1;
  var b;
  var c;
  while (d <= f) {
    b = Math.floor((d + f) / 2);
    c = a[b];
    if (c < e) {
      d = b + 1
    } else {
      if (c > e) {
        f = b - 1
      } else {
        return b
      }
    }
  }
  return b
}
var NovaManager = function(e, f, c, a, d, b) {
  return (function() {
    var g = {
      runStatus: {
        running: false,
        stopped: false,
        reset: false
      },
      timeField: a,
      speed: (d) ? d : 0,
      delay: b,
      clocklo: c.lo,
      clockhi: c.hi,
      clockdt: c.dt,
      clockmethod: c.method,
      fixSpeed: function(h) {
        g.speed = h;
        if (g.runStatus.running) {
          g.stop();
          g.restart()
        }
      },
      fixClock: function(i, h) {
        g["clock" + i] = h
      },
      timerBuilder: function(l, k, i) {
        var h = {
          running: true,
          stopped: false,
          reset: false
        };
        if (k > 0) {
          var j = g.timer = setInterval(function() {
            if (!h.running) {
              clearInterval(j);
              return
            }
            val = l();
            if (val) {
              h.running = false
            }
          }, k)
          } else {
            d3.timer(function() {
              if (!h.running) {
                return true
              }
              val = l();
              if (val) {
                h.running = false;
                return true
              }
            }, (i) ? i : 0)
          }
        return h
      },
      step: function() {
        if (g.runStatus.running || c.current >= c.hi) {
          return
        }
        g.iterate()
      },
      iterate: function() {
        c.step();
        g.timeField.value = c.current;
        e();
        if (c.current >= c.hi) {
          return true
        }
      },
      stop: function() {
        g.runStatus.running = false;
        g.runStatus.stopped = true
      },
      restart: function() {
        if (g.runStatus.running) {
          return
        }
        if (g.runStatus.stopped) {
          g.runStatus = g.timerBuilder(g.iterate, g.speed, g.delay)
        } else {
          g.run()
        }
      },
      reset: function() {
        g.runStatus.running = false;
        g.runStatus.reset = true;
        c.lo = g.clocklo;
        c.hi = g.clockhi;
        c.dt = g.clockdt;
        c.method = g.clockmethod;
        g.timeField.value = c.lo;
        f()
      },
      run: function() {
        if (!g.runStatus.reset) {
          g.reset()
        }
        g.runStatus = g.timerBuilder(g.iterate, g.speed, g.delay)
      },
      showSliderValue: function(i, j) {
        var h = document.getElementById(i);
        h.value = j
      }
    };
    g.timeField.value = c.lo;
    return {
      step: g.step,
      stop: g.stop,
      restart: g.restart,
      reset: g.reset,
      run: g.run,
      fixSpeed: g.fixSpeed,
      showSliderValue: g.showSliderValue,
      fixClock: g.fixClock
    }
  })()
};
